"""
train_longShort:
implementation of the long short term memory to forecast time series
"""

import random, json, datetime, re
import numpy as np
import pandas as pd
import scipy as sp
import matplotlib.pyplot as plt
import keras
import tensorflow
from keras import backend as K
from keras.layers import Input, Dense, Conv2D, MaxPooling2D, UpSampling2D, Flatten, LSTM, RepeatVector, Dropout
from keras.layers import Embedding, GlobalMaxPooling1D, SpatialDropout1D
from keras.models import Model, Sequential
from keras.callbacks import TensorBoard
from keras.preprocessing.text import Tokenizer
from keras.preprocessing.sequence import pad_sequences
from sklearn.model_selection import train_test_split
from keras.utils import to_categorical
from keras.models import Sequential

from sklearn.preprocessing import MinMaxScaler, LabelEncoder, StandardScaler
from sklearn.metrics import mean_squared_error
from keras.wrappers.scikit_learn import KerasRegressor
from sklearn.model_selection import cross_val_score
from sklearn.model_selection import KFold
from sklearn.pipeline import Pipeline

import lernia.train_score as t_s
from deep_lernia.train_keras import trainKeras


class timeSeries(trainKeras):
    """keras on time series"""
    def __init__(self,X,y=[None]):
        """initiate parent and set Xy"""
        trainKeras.__init__(self,X,y=y)

    def longShort(self):
        """define an autoencoder model"""
        inputs = Input(shape=(timesteps, input_dim))
        encoded = LSTM(latent_dim)(inputs)
        decoded = RepeatVector(timesteps)(encoded)
        decoded = LSTM(input_dim, return_sequences=True)(decoded)
        sequence_autoencoder = Model(inputs, decoded)
        encoder = Model(inputs, encoded)
        self.model = encoder

    def textModel(self,max_words=400,max_phrase_len=30):
        """define a model for text"""
        model = Sequential()
        model.add(Embedding(input_dim=max_words,output_dim=256,input_length=max_phrase_len))
        model.add(SpatialDropout1D(0.3))
        model.add(LSTM(256, dropout = 0.3, recurrent_dropout = 0.3))
        model.add(Dense(256, activation = 'relu'))
        model.add(Dropout(0.3))
        model.add(Dense(5, activation = 'softmax'))
        model.compile(loss='categorical_crossentropy',optimizer='Adam',metrics=['accuracy'])
        self.model = model

    def modelLongShort(self,input_shape=(1,1)):
        """define baseline model"""
        model = Sequential()
        model.add(LSTM(50,input_shape=input_shape))
	#model.add(LSTM(neurons,batch_input_shape=(batch_size,X.shape[1],X.shape[2]),stateful=True))
        model.add(Dense(1))
        model.compile(loss='mae', optimizer='adam')
	#model.compile(loss='mean_squared_error', optimizer='adam')
        self.model = model

    def lstmBatch(self,batch_size = 1, neurons = 4):
        """ long short with batch_size"""
        shape = self.X.shape
        model = Sequential()
        model.add(LSTM(neurons, batch_input_shape=(batch_size,1,shape[1]),stateful=True))
        model.add(Dense(shape[1]))
        model.compile(loss='mean_squared_error', optimizer='adam')
        self.batch_size = batch_size
        self.model = model
    
    def modelLongShortDeep(self,input_shape=(1,1)):
        """deep lstm"""
        regressor = Sequential()
        regressor.add(LSTM(units=50,return_sequences=True,input_shape=input_shape))
        regressor.add(Dropout(0.2))
        regressor.add(LSTM(units = 50, return_sequences = True))
        regressor.add(Dropout(0.2))
        regressor.add(LSTM(units = 50, return_sequences = True))
        regressor.add(Dropout(0.2))
        regressor.add(LSTM(units = 50))
        regressor.add(Dropout(0.2))
        regressor.add(Dense(units = 1))
        regressor.compile(optimizer = 'adam', loss = 'mean_squared_error')
        self.model = regressor

    def newModel(self):
        """define a new model"""
        print("new long short term memory model",self.input_shape)
        self.modelLongShort(input_shape=self.input_shape)
        
    def defModel(self):
        """create or return an existin model"""
        try:
            self.model
        except:
            self.newModel()
    
    def prepareLongShort(self,X,n_in=1,n_out=1):
        """perform a n_in shift for each of training feature"""
        post = pd.DataFrame(X)
        pre = [post.shift(i) for i in range(1, n_in+1)]
        pre = pd.concat(pre, axis=1)
        pre.fillna(0, inplace=True)
        return pre.values, post.values
        Xy = np.append(y,X,axis=1)
        n_vars = Xy.shape[1]
        df = pd.DataFrame(Xy)
        cols, names = list(), list()
        for i in range(n_in, 0, -1):
            cols.append(df.shift(i))
            names += [('var%d(t-%d)' % (j+1, i)) for j in range(n_vars)]
        for i in range(1, n_out):
            cols.append(df.shift(-i))
            names += [('var%d(t+%d)' % (j+1, i)) for j in range(n_vars)]
        reframed = pd.concat(cols, axis=1)
        reframed.columns = names
        reframed.replace(float('nan'),0,inplace=True)
        return reframed.values

    def splitSet(self,X1,y1,portion=.75,n_in=1,n_out=1,shuffle=False):
        """overwrite split set preparing Xy"""
        N = X1.shape[0]
        if shuffle:
            shuffleL = np.arange(0,N)
            n = int(np.random.random(1)*N)
            shuffleL = np.roll(shuffleL,n)
        else:
            shuffleL = list(range(N))
        y = np.array(y1)[shuffleL]
        X = np.array(X1)[shuffleL]
        ahead = int(X.shape[0]*portion)
        pre, post = self.prepareLongShort(X,n_in=1,n_out=1)
        n_pred = 100
        X_train, X_test = pre[0:ahead], pre[ahead:]
        y_train, y_test = post[0:ahead], post[ahead:]
        X_train = X_train.reshape(X_train.shape[0], -1, X_train.shape[1])
        X_test = X_test.reshape(X_test.shape[0], -1, X_test.shape[1])
        y_train = y_train.reshape(len(y_train),-1)
        y_test = y_test.reshape(len(y_test),-1)
        if len(X_train) == 0:
            raise Exception('Empty training set')
        return X_train, X_test, y_train, y_test

    def train(self,batch_size=1,nb_epoch=300,shuffle=False,**args):
        """train a baseline model resetting the states every nb_epochs"""
        X_train, X_test, y_train, y_test = self.splitSet(self.X,self.y,shuffle=shuffle)
        for i in range(nb_epoch):
            history = self.model.fit(X_train,y_train
                                     ,epochs=1,batch_size=batch_size
                                     ,validation_data=(X_test,y_test)
                                     ,verbose=2,shuffle=False)
            self.model.reset_states()
            self.history.append(history)
        self.model.predict(X_train, batch_size=batch_size)
        y_pred = self.predict(X_test,batch_size=batch_size)
        kpi = t_s.calcMetrics(y_pred[:,0], y_test[:,0])
        return kpi

    def predict(self,X_test,batch_size=1):
        """prediction for the short long term memory"""
        y_pred = []
        if X_test.shape == 2:
            X_test = self.reshape(X_test)
        for i in range(len(X_test)):
            X1 = X_test[i,:]
            X1 = X1.reshape(1, len(X1), X1.shape[1] )
            yhat = self.model.predict(X1, batch_size=batch_size)
            yhat = yhat[0,0]
            y_pred.append(yhat)
        return np.array(y_pred).reshape(len(y_pred),-1)
    
    def forecast(self,X,y=[None],batch_size=16):
        """forecast using longshort"""
        if not any(y):
            y = self.y
        #X = X.reshape(1, 1, len(X))
        print(X.shape)
        Xy = self.prepareLongShort(X)
        X_test = Xy[:,:]
        print(X_test.shape)
        yhat = self.model.predict(X_test, batch_size=batch_size)
        return yhat[0,0]

    def forecastLongShort(self,y,ahead=28,epoch=50,n_in=2,n_out=1):
        """forecast on ahead time points"""
        portion = 1. - ahead/len(y)
        self.setLimit(y)
        X_train, X_test, y_train, y_test = self.splitSet(self.X,y,portion=portion)
        self.defModel()
        self.history = self.model.fit(X_train,y_train,epochs=epoch,batch_size=72,validation_data=(X_test,y_test),verbose=0,shuffle=False)#,callbacks=[TensorBoard(log_dir='/tmp/lstm')])
        y_scaled = self.model.predict(X_test)
        y_pred = y_scaled[:,0]*(self.yMax+self.yMin) + self.yMin
        y_test1 = y_test*(self.yMax+self.yMin) + self.yMin
        if False:
            plt.plot(y[ahead:],label="test")
            plt.plot(y_pred,label="pred")
            plt.legend()
            plt.show()
        
        kpi = t_s.calcMetrics(y_pred, y_test1)
        return self.model, kpi

    def toSupervised(self,dataset,look_back=1):
        """reshape to supervised""" 
        dataX, dataY = [], []
        for i in range(len(dataset)-look_back-1):
            a = dataset[i:(i+look_back), 0]
            dataX.append(a)
            dataY.append(dataset[i + look_back, 0])
        return np.array(dataX), np.array(dataY)

    def reshape(self,X,mode=None,n_in=1):
        """reshape the input dataset"""
        X, y = self.prepareLongShort(X,n_in=1)
        X_test = X.reshape((X.shape[0], 1, X.shape[1]))
        return X_test
    
    def plotPredVsRef(self,X,y,portion=.5):
        X_train, X_test, y_train, y_test = self.splitSet(X,y,portion=.5)
        y_scaled = self.model.predict(X_test)
        y_pred = y_scaled[:,0]*(self.yMax+self.yMin) + self.yMin
        y_test1 = y_test*(self.yMax+self.yMin) + self.yMin
        y_pred1 = self.model.predict(X_train)
        y_pred1 = np.reshape(scaler.inverse_transform(y_pred1),len(y_pred1))[1:]
        y_train1 = np.reshape(scaler.inverse_transform([y_train]),len(y_train))[:-1]
        kpi1 = t_s.calcMetrics(y_train1,y_pred1)
        fig, ax = plt.subplots(1,2)
        ax[0].plot(y_train1)
        ax[0].plot(y_pred1)
        ax[0].set_title("train cor %.2f rel_err %.2f" % (kpi1['cor'],kpi1['rel_err']))
        ax[1].plot(y_test1)
        ax[1].plot(y_pred)
        ax[1].set_title("test cor %.2f rel_err %.2f" % (kpi['cor'],kpi['rel_err']))
        plt.show()
        
    def forecastSingle(self,y,look_back=1,ahead=28,epochs=100,isPlot=False):
        #np.random.seed(7)
        X = y.copy()
        if len(y.shape) == 1:
            X = np.reshape(y,(len(y),1))
        X = X.astype('float32')
        self.scaler = MinMaxScaler(feature_range=(0, 1))
        X = self.scaler.fit_transform(X)
        train_size = int(len(y) - ahead)
        test_size = ahead
        train, test = X[0:train_size,:], X[train_size:,:]
        X_train, y_train = self.toSupervised(train, look_back)
        X_test, y_test = self.toSupervised(test, look_back)
        X_train = np.reshape(X_train, (X_train.shape[0], 1, X_train.shape[1]))
        X_test = np.reshape(X_test, (X_test.shape[0], 1, X_test.shape[1]))
        self.input_shape = (1,look_back)
        self.defModel()
        self.model.fit(X_train,y_train,epochs=epochs,batch_size=1,verbose=0)
        y_pred = self.model.predict(X_test)
        # X_test1 = X_train[-ahead:]
        # y_test1 = y_train[-ahead:]
        # y_pred = []
        # for i in range(ahead):
        #     yhat = model.predict(X_test1)
        #     yhat = list(yhat[-1])
        #     y_pred.append(yhat[0])
        #     for j in range(X_test1.shape[2]-1):
        #         yhat.append(X_test1[-1][0][j+1])
        #     np.vstack((X_test1,[[yhat]]))
        # y_pred = np.array(y_pred)
        y_pred = np.reshape(scaler.inverse_transform(y_pred),len(y_pred))[1:]
        y_test1 = np.reshape(scaler.inverse_transform([y_test]),len(y_test))[:-1]
        kpi = t_s.calcMetrics(y_test1,y_pred)
        if isPlot:
            y_pred1 = self.model.predict(X_train)
            y_pred1 = np.reshape(self.scaler.inverse_transform(y_pred1),len(y_pred1))[1:]
            y_train1 = np.reshape(self.scaler.inverse_transform([y_train]),len(y_train))[:-1]
            kpi1 = t_s.calcMetrics(y_train1,y_pred1)
            fig, ax = plt.subplots(1,2)
            ax[0].plot(y_train1)
            ax[0].plot(y_pred1)
            ax[0].set_title("train cor %.2f rel_err %.2f" % (kpi1['cor'],kpi1['rel_err']))
            ax[1].plot(y_test1)
            ax[1].plot(y_pred)
            ax[1].set_title("test cor %.2f rel_err %.2f" % (kpi['cor'],kpi['rel_err']))
            plt.show()
        return self.model, kpi
    
    def predictLongshort(self,y,nStep=60):
        """prediction on time series"""
        X = self.X
        sc = MinMaxScaler(feature_range = (0, 1))
        X = sc.fit_transform(X)
        X_train = []
        y_train = []
        for i in range(nStep,X.shape):
            X_train.append(X[i-nStep:i, 0])
            y_train.append(X[i, 0])
        X_train, y_train = np.array(X_train), np.array(y_train)
        X_train = np.reshape(X_train, (X_train.shape[0], X_train.shape[1], 1))
        regressor = self.modelLongShort1()
        regressor.fit(X_train, y_train, epochs = 100, batch_size = 32)
        if False:
            dataset_total = pd.concat((dataset_train['Open'], dataset_test['Open']), axis = 0)
            inputs = dataset_total[len(dataset_total) - len(dataset_test) - 60:].values
            inputs = inputs.reshape(-1,1)
            inputs = sc.transform(inputs)
            X_test = []
            for i in range(60, 76):
                X_test.append(inputs[i-60:i, 0])
                X_test = np.array(X_test)
                X_test = np.reshape(X_test, (X_test.shape[0], X_test.shape[1], 1))
                predicted_stock_price = regressor.predict(X_test)
                predicted_stock_price = sc.inverse_transform(predicted_stock_price)
        return regressor


