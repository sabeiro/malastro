;; Object semanticdb-project-database-file
;; SEMANTICDB Tags save file
(semanticdb-project-database-file "semanticdb-project-database-file"
  :tables
  (list
    (semanticdb-table "semanticdb-table"
      :major-mode python-mode
      :tags 
        '( ("itertools" include nil nil [395 411])
            ("functools" include nil nil [412 441])
            ("warnings" include nil nil [442 457])
            ("numpy" include nil nil [459 477])
            ("scipy.spatial" include nil nil [478 512])
            ("scipy.sparse" include nil nil [513 548])
            ("scipy.sparse" include nil nil [549 582])
            ("joblib" include nil nil [583 637])
            ("_num_samples" include nil nil [663 682])
            ("check_non_negative" include nil nil [707 732])
            ("check_array" include nil nil [746 764])
            ("gen_even_slices" include nil nil [778 800])
            ("get_chunk_n_rows" include nil nil [814 850])
            ("gen_batches" include nil nil [814 850])
            ("is_scalar_nan" include nil nil [864 884])
            ("safe_sparse_dot" include nil nil [906 939])
            ("row_norms" include nil nil [906 939])
            ("normalize" include nil nil [961 977])
            ("_get_mask" include nil nil [997 1013])
            ("_deprecate_positional_args" include nil nil [1038 1071])
            ("_sparse_manhattan" include nil nil [1094 1137])
            ("_chi2_kernel_fast" include nil nil [1094 1137])
            ("DataConversionWarning" include nil nil [1156 1184])
            ("_return_float_dtype" function
               (:documentation "
    1. If dtype of X and Y is float32, then dtype float32 is returned.
    2. Else dtype float is returned.
    "
                :arguments 
                  ( ("X" variable nil (reparse-symbol function_parameters) [1231 1232])
                    ("Y" variable nil (reparse-symbol function_parameters) [1234 1235]))                  )
                nil [1207 1767])
            ("check_pairwise_arrays" function
               (:documentation " Set X and Y appropriately and checks inputs

    If Y is None, it is set as a pointer to X (i.e. not a copy).
    If Y is given, this does not happen.
    All distance metrics should use this function first to assert that the
    given parameters are correct and safe to use.

    Specifically, this function first ensures that both X and Y are arrays,
    then checks that they are at least two dimensional while ensuring that
    their elements are floats (or dtype if provided). Finally, the function
    checks that the size of the second dimension of the two arrays is equal, or
    the equivalent check for a precomputed distance matrix.

    Parameters
    ----------
    X : {array-like, sparse matrix}, shape (n_samples_a, n_features)

    Y : {array-like, sparse matrix}, shape (n_samples_b, n_features)

    precomputed : bool
        True if X is to be treated as precomputed distances to the samples in
        Y.

    dtype : string, type, list of types or None (default=None)
        Data type required for X and Y. If None, the dtype will be an
        appropriate float type selected by _return_float_dtype.

        .. versionadded:: 0.18

    accept_sparse : string, boolean or list/tuple of strings
        String[s] representing allowed sparse matrix formats, such as 'csc',
        'csr', etc. If the input is sparse but not in the allowed format,
        it will be converted to the first listed format. True allows the input
        to be any format. False means that a sparse matrix input will
        raise an error.

    force_all_finite : boolean or 'allow-nan', (default=True)
        Whether to raise an error on np.inf, np.nan, pd.NA in array. The
        possibilities are:

        - True: Force all values of array to be finite.
        - False: accepts np.inf, np.nan, pd.NA in array.
        - 'allow-nan': accepts only np.nan and pd.NA values in array. Values
          cannot be infinite.

        .. versionadded:: 0.22
           ``force_all_finite`` accepts the string ``'allow-nan'``.

        .. versionchanged:: 0.23
           Accepts `pd.NA` and converts it into `np.nan`

    copy : bool
        Whether a forced copy will be triggered. If copy=False, a copy might
        be triggered by a conversion.

        .. versionadded:: 0.22

    Returns
    -------
    safe_X : {array-like, sparse matrix}, shape (n_samples_a, n_features)
        An array equal to X, guaranteed to be a numpy array.

    safe_Y : {array-like, sparse matrix}, shape (n_samples_b, n_features)
        An array equal to Y if Y was not None, guaranteed to be a numpy array.
        If Y was None, safe_Y will be a pointer to X.

    "
                :arguments 
                  ( ("X" variable nil (reparse-symbol function_parameters) [1823 1824])
                    ("Y" variable nil (reparse-symbol function_parameters) [1826 1827])
                    ("precomputed" variable nil (reparse-symbol function_parameters) [1832 1843])
                    ("dtype" variable nil (reparse-symbol function_parameters) [1851 1856])
                    ("accept_sparse" variable nil (reparse-symbol function_parameters) [1889 1902])
                    ("force_all_finite" variable nil (reparse-symbol function_parameters) [1910 1926])
                    ("copy" variable nil (reparse-symbol function_parameters) [1959 1963]))                  
                :decorators 
                  ( ("_deprecate_positional_args" function (:type "decorator") nil nil))                  )
                nil [1769 5942])
            ("check_paired_arrays" function
               (:documentation " Set X and Y appropriately and checks inputs for paired distances

    All paired distance metrics should use this function first to assert that
    the given parameters are correct and safe to use.

    Specifically, this function first ensures that both X and Y are arrays,
    then checks that they are at least two dimensional while ensuring that
    their elements are floats. Finally, the function checks that the size
    of the dimensions of the two arrays are equal.

    Parameters
    ----------
    X : {array-like, sparse matrix}, shape (n_samples_a, n_features)

    Y : {array-like, sparse matrix}, shape (n_samples_b, n_features)

    Returns
    -------
    safe_X : {array-like, sparse matrix}, shape (n_samples_a, n_features)
        An array equal to X, guaranteed to be a numpy array.

    safe_Y : {array-like, sparse matrix}, shape (n_samples_b, n_features)
        An array equal to Y if Y was not None, guaranteed to be a numpy array.
        If Y was None, safe_Y will be a pointer to X.

    "
                :arguments 
                  ( ("X" variable nil (reparse-symbol function_parameters) [5968 5969])
                    ("Y" variable nil (reparse-symbol function_parameters) [5971 5972]))                  )
                nil [5944 7236])
            ("euclidean_distances" function
               (:documentation "
    Considering the rows of X (and Y=X) as vectors, compute the
    distance matrix between each pair of vectors.

    For efficiency reasons, the euclidean distance between a pair of row
    vector x and y is computed as::

        dist(x, y) = sqrt(dot(x, x) - 2 * dot(x, y) + dot(y, y))

    This formulation has two advantages over other ways of computing distances.
    First, it is computationally efficient when dealing with sparse data.
    Second, if one argument varies but the other remains unchanged, then
    `dot(x, x)` and/or `dot(y, y)` can be pre-computed.

    However, this is not the most precise way of doing this computation, and
    the distance matrix returned by this function may not be exactly
    symmetric as required by, e.g., ``scipy.spatial.distance`` functions.

    Read more in the :ref:`User Guide <metrics>`.

    Parameters
    ----------
    X : {array-like, sparse matrix}, shape (n_samples_1, n_features)

    Y : {array-like, sparse matrix}, shape (n_samples_2, n_features)

    Y_norm_squared : array-like, shape (n_samples_2, ), optional
        Pre-computed dot-products of vectors in Y (e.g.,
        ``(Y**2).sum(axis=1)``)
        May be ignored in some cases, see the note below.

    squared : boolean, optional
        Return squared Euclidean distances.

    X_norm_squared : array-like of shape (n_samples,), optional
        Pre-computed dot-products of vectors in X (e.g.,
        ``(X**2).sum(axis=1)``)
        May be ignored in some cases, see the note below.

    Notes
    -----
    To achieve better accuracy, `X_norm_squared`Â and `Y_norm_squared` may be
    unused if they are passed as ``float32``.

    Returns
    -------
    distances : array, shape (n_samples_1, n_samples_2)

    Examples
    --------
    >>> from sklearn.metrics.pairwise import euclidean_distances
    >>> X = [[0, 1], [1, 1]]
    >>> # distance between rows of X
    >>> euclidean_distances(X, X)
    array([[0., 1.],
           [1., 0.]])
    >>> # get distance to origin
    >>> euclidean_distances(X, [[0, 0]])
    array([[1.        ],
           [1.41421356]])

    See also
    --------
    paired_distances : distances betweens pairs of elements of X and Y.
    "
                :arguments 
                  ( ("X" variable nil (reparse-symbol function_parameters) [7311 7312])
                    ("Y" variable nil (reparse-symbol function_parameters) [7314 7315])
                    ("Y_norm_squared" variable nil (reparse-symbol function_parameters) [7325 7339])
                    ("squared" variable nil (reparse-symbol function_parameters) [7346 7353])
                    ("X_norm_squared" variable nil (reparse-symbol function_parameters) [7385 7399]))                  
                :decorators 
                  ( ("_deprecate_positional_args" function (:type "decorator") nil nil))                  )
                nil [7259 11572])
            ("nan_euclidean_distances" function
               (:documentation "Calculate the euclidean distances in the presence of missing values.

    Compute the euclidean distance between each pair of samples in X and Y,
    where Y=X is assumed if Y=None. When calculating the distance between a
    pair of samples, this formulation ignores feature coordinates with a
    missing value in either sample and scales up the weight of the remaining
    coordinates:

        dist(x,y) = sqrt(weight * sq. distance from present coordinates)
        where,
        weight = Total # of coordinates / # of present coordinates

    For example, the distance between ``[3, na, na, 6]`` and ``[1, na, 4, 5]``
    is:

        .. math::
            \\\\sqrt{\\\\frac{4}{2}((3-1)^2 + (6-5)^2)}

    If all the coordinates are missing or if there are no common present
    coordinates then NaN is returned for that pair.

    Read more in the :ref:`User Guide <metrics>`.

    .. versionadded:: 0.22

    Parameters
    ----------
    X : array-like, shape=(n_samples_1, n_features)

    Y : array-like, shape=(n_samples_2, n_features)

    squared : bool, default=False
        Return squared Euclidean distances.

    missing_values : np.nan or int, default=np.nan
        Representation of missing value

    copy : boolean, default=True
        Make and use a deep copy of X and Y (if Y exists)

    Returns
    -------
    distances : array, shape (n_samples_1, n_samples_2)

    Examples
    --------
    >>> from sklearn.metrics.pairwise import nan_euclidean_distances
    >>> nan = float(\"NaN\")
    >>> X = [[0, 1], [1, nan]]
    >>> nan_euclidean_distances(X, X) # distance between rows of X
    array([[0.        , 1.41421356],
           [1.41421356, 0.        ]])

    >>> # get distance to origin
    >>> nan_euclidean_distances(X, [[0, 0]])
    array([[1.        ],
           [1.41421356]])

    References
    ----------
    * John K. Dixon, \"Pattern Recognition with Partly Missing Data\",
      IEEE Transactions on Systems, Man, and Cybernetics, Volume: 9, Issue:
      10, pp. 617 - 621, Oct. 1979.
      http://ieeexplore.ieee.org/abstract/document/4310090/

    See also
    --------
    paired_distances : distances between pairs of elements of X and Y.
    "
                :arguments 
                  ( ("X" variable nil (reparse-symbol function_parameters) [11630 11631])
                    ("Y" variable nil (reparse-symbol function_parameters) [11633 11634])
                    ("squared" variable nil (reparse-symbol function_parameters) [11644 11651])
                    ("missing_values" variable nil (reparse-symbol function_parameters) [11687 11701])
                    ("copy" variable nil (reparse-symbol function_parameters) [11710 11714]))                  
                :decorators 
                  ( ("_deprecate_positional_args" function (:type "decorator") nil nil))                  )
                nil [11574 15260])
            ("_euclidean_distances_upcast" function
               (:documentation "Euclidean distances between X and Y

    Assumes X and Y have float32 dtype.
    Assumes XX and YY have float64 dtype or are None.

    X and Y are upcast to float64 by chunks, which size is chosen to limit
    memory increase by approximately 10% (at least 10MiB).
    "
                :arguments 
                  ( ("X" variable nil (reparse-symbol function_parameters) [15294 15295])
                    ("XX" variable nil (reparse-symbol function_parameters) [15297 15299])
                    ("Y" variable nil (reparse-symbol function_parameters) [15306 15307])
                    ("YY" variable nil (reparse-symbol function_parameters) [15314 15316])
                    ("batch_size" variable nil (reparse-symbol function_parameters) [15323 15333]))                  )
                nil [15262 17908])
            ("_argmin_min_reduce" function (:arguments 
              ( ("dist" variable nil (reparse-symbol function_parameters) [17933 17937])
                ("start" variable nil (reparse-symbol function_parameters) [17939 17944]))              ) nil [17910 18061])
            ("pairwise_distances_argmin_min" function
               (:documentation "Compute minimum distances between one point and a set of points.

    This function computes for each row in X, the index of the row of Y which
    is closest (according to the specified distance). The minimal distances are
    also returned.

    This is mostly equivalent to calling:

        (pairwise_distances(X, Y=Y, metric=metric).argmin(axis=axis),
         pairwise_distances(X, Y=Y, metric=metric).min(axis=axis))

    but uses much less memory, and is faster for large arrays.

    Parameters
    ----------
    X : {array-like, sparse matrix}, shape (n_samples1, n_features)
        Array containing points.

    Y : {array-like, sparse matrix}, shape (n_samples2, n_features)
        Arrays containing points.

    axis : int, optional, default 1
        Axis along which the argmin and distances are to be computed.

    metric : string or callable, default 'euclidean'
        metric to use for distance computation. Any metric from scikit-learn
        or scipy.spatial.distance can be used.

        If metric is a callable function, it is called on each
        pair of instances (rows) and the resulting value recorded. The callable
        should take two arrays as input and return one value indicating the
        distance between them. This works for Scipy's metrics, but is less
        efficient than passing the metric name as a string.

        Distance matrices are not supported.

        Valid values for metric are:

        - from scikit-learn: ['cityblock', 'cosine', 'euclidean', 'l1', 'l2',
          'manhattan']

        - from scipy.spatial.distance: ['braycurtis', 'canberra', 'chebyshev',
          'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski',
          'mahalanobis', 'minkowski', 'rogerstanimoto', 'russellrao',
          'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean',
          'yule']

        See the documentation for scipy.spatial.distance for details on these
        metrics.

    metric_kwargs : dict, optional
        Keyword arguments to pass to specified metric function.

    Returns
    -------
    argmin : numpy.ndarray
        Y[argmin[i], :] is the row in Y that is closest to X[i, :].

    distances : numpy.ndarray
        distances[i] is the distance between the i-th row in X and the
        argmin[i]-th row in Y.

    See also
    --------
    sklearn.metrics.pairwise_distances
    sklearn.metrics.pairwise_distances_argmin
    "
                :arguments 
                  ( ("X" variable nil (reparse-symbol function_parameters) [18125 18126])
                    ("Y" variable nil (reparse-symbol function_parameters) [18128 18129])
                    ("axis" variable nil (reparse-symbol function_parameters) [18134 18138])
                    ("metric" variable nil (reparse-symbol function_parameters) [18142 18148])
                    ("metric_kwargs" variable nil (reparse-symbol function_parameters) [18196 18209]))                  
                :decorators 
                  ( ("_deprecate_positional_args" function (:type "decorator") nil nil))                  )
                nil [18063 21030])
            ("pairwise_distances_argmin" function
               (:documentation "Compute minimum distances between one point and a set of points.

    This function computes for each row in X, the index of the row of Y which
    is closest (according to the specified distance).

    This is mostly equivalent to calling:

        pairwise_distances(X, Y=Y, metric=metric).argmin(axis=axis)

    but uses much less memory, and is faster for large arrays.

    This function works with dense 2D arrays only.

    Parameters
    ----------
    X : array-like
        Arrays containing points. Respective shapes (n_samples1, n_features)
        and (n_samples2, n_features)

    Y : array-like
        Arrays containing points. Respective shapes (n_samples1, n_features)
        and (n_samples2, n_features)

    axis : int, optional, default 1
        Axis along which the argmin and distances are to be computed.

    metric : string or callable
        metric to use for distance computation. Any metric from scikit-learn
        or scipy.spatial.distance can be used.

        If metric is a callable function, it is called on each
        pair of instances (rows) and the resulting value recorded. The callable
        should take two arrays as input and return one value indicating the
        distance between them. This works for Scipy's metrics, but is less
        efficient than passing the metric name as a string.

        Distance matrices are not supported.

        Valid values for metric are:

        - from scikit-learn: ['cityblock', 'cosine', 'euclidean', 'l1', 'l2',
          'manhattan']

        - from scipy.spatial.distance: ['braycurtis', 'canberra', 'chebyshev',
          'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski',
          'mahalanobis', 'minkowski', 'rogerstanimoto', 'russellrao',
          'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean',
          'yule']

        See the documentation for scipy.spatial.distance for details on these
        metrics.

    metric_kwargs : dict
        keyword arguments to pass to specified metric function.

    Returns
    -------
    argmin : numpy.ndarray
        Y[argmin[i], :] is the row in Y that is closest to X[i, :].

    See also
    --------
    sklearn.metrics.pairwise_distances
    sklearn.metrics.pairwise_distances_argmin_min
    "
                :arguments 
                  ( ("X" variable nil (reparse-symbol function_parameters) [21090 21091])
                    ("Y" variable nil (reparse-symbol function_parameters) [21093 21094])
                    ("axis" variable nil (reparse-symbol function_parameters) [21099 21103])
                    ("metric" variable nil (reparse-symbol function_parameters) [21107 21113])
                    ("metric_kwargs" variable nil (reparse-symbol function_parameters) [21157 21170]))                  
                :decorators 
                  ( ("_deprecate_positional_args" function (:type "decorator") nil nil))                  )
                nil [21032 23655])
            ("haversine_distances" function
               (:documentation "Compute the Haversine distance between samples in X and Y

    The Haversine (or great circle) distance is the angular distance between
    two points on the surface of a sphere. The first distance of each point is
    assumed to be the latitude, the second is the longitude, given in radians.
    The dimension of the data must be 2.

    .. math::
       D(x, y) = 2\\\\arcsin[\\\\sqrt{\\\\sin^2((x1 - y1) / 2)
                                + \\\\cos(x1)\\\\cos(y1)\\\\sin^2((x2 - y2) / 2)}]

    Parameters
    ----------
    X : array_like, shape (n_samples_1, 2)

    Y : array_like, shape (n_samples_2, 2), optional

    Returns
    -------
    distance : {array}, shape (n_samples_1, n_samples_2)

    Notes
    -----
    As the Earth is nearly spherical, the haversine formula provides a good
    approximation of the distance between two points of the Earth surface, with
    a less than 1% error on average.

    Examples
    --------
    We want to calculate the distance between the Ezeiza Airport
    (Buenos Aires, Argentina) and the Charles de Gaulle Airport (Paris, France)

    >>> from sklearn.metrics.pairwise import haversine_distances
    >>> from math import radians
    >>> bsas = [-34.83333, -58.5166646]
    >>> paris = [49.0083899664, 2.53844117956]
    >>> bsas_in_radians = [radians(_) for _ in bsas]
    >>> paris_in_radians = [radians(_) for _ in paris]
    >>> result = haversine_distances([bsas_in_radians, paris_in_radians])
    >>> result * 6371000/1000  # multiply by Earth radius to get kilometers
    array([[    0.        , 11099.54035582],
           [11099.54035582,     0.        ]])
    "
                :arguments 
                  ( ("X" variable nil (reparse-symbol function_parameters) [23681 23682])
                    ("Y" variable nil (reparse-symbol function_parameters) [23684 23685]))                  )
                nil [23657 25437])
            ("manhattan_distances" function
               (:documentation " Compute the L1 distances between the vectors in X and Y.

    With sum_over_features equal to False it returns the componentwise
    distances.

    Read more in the :ref:`User Guide <metrics>`.

    Parameters
    ----------
    X : array_like
        An array with shape (n_samples_X, n_features).

    Y : array_like, optional
        An array with shape (n_samples_Y, n_features).

    sum_over_features : bool, default=True
        If True the function returns the pairwise distance matrix
        else it returns the componentwise L1 pairwise-distances.
        Not supported for sparse matrix inputs.

    Returns
    -------
    D : array
        If sum_over_features is False shape is
        (n_samples_X * n_samples_Y, n_features) and D contains the
        componentwise L1 pairwise-distances (ie. absolute difference),
        else shape is (n_samples_X, n_samples_Y) and D contains
        the pairwise L1 distances.

    Notes
    --------
    When X and/or Y are CSR sparse matrices and they are not already
    in canonical format, this function modifies them in-place to
    make them canonical.

    Examples
    --------
    >>> from sklearn.metrics.pairwise import manhattan_distances
    >>> manhattan_distances([[3]], [[3]])
    array([[0.]])
    >>> manhattan_distances([[3]], [[2]])
    array([[1.]])
    >>> manhattan_distances([[2]], [[3]])
    array([[1.]])
    >>> manhattan_distances([[1, 2], [3, 4]],\\
         [[1, 2], [0, 3]])
    array([[0., 2.],
           [4., 4.]])
    >>> import numpy as np
    >>> X = np.ones((1, 2))
    >>> y = np.full((2, 2), 2.)
    >>> manhattan_distances(X, y, sum_over_features=False)
    array([[1., 1.],
           [1., 1.]])
    "
                :arguments 
                  ( ("X" variable nil (reparse-symbol function_parameters) [25491 25492])
                    ("Y" variable nil (reparse-symbol function_parameters) [25494 25495])
                    ("sum_over_features" variable nil (reparse-symbol function_parameters) [25505 25522]))                  
                :decorators 
                  ( ("_deprecate_positional_args" function (:type "decorator") nil nil))                  )
                nil [25439 28042])
            ("cosine_distances" function
               (:documentation "Compute cosine distance between samples in X and Y.

    Cosine distance is defined as 1.0 minus the cosine similarity.

    Read more in the :ref:`User Guide <metrics>`.

    Parameters
    ----------
    X : array_like, sparse matrix
        with shape (n_samples_X, n_features).

    Y : array_like, sparse matrix (optional)
        with shape (n_samples_Y, n_features).

    Returns
    -------
    distance matrix : array
        An array with shape (n_samples_X, n_samples_Y).

    See also
    --------
    sklearn.metrics.pairwise.cosine_similarity
    scipy.spatial.distance.cosine : dense matrices only
    "
                :arguments 
                  ( ("X" variable nil (reparse-symbol function_parameters) [28065 28066])
                    ("Y" variable nil (reparse-symbol function_parameters) [28068 28069]))                  )
                nil [28044 29072])
            ("paired_euclidean_distances" function
               (:documentation "
    Computes the paired euclidean distances between X and Y

    Read more in the :ref:`User Guide <metrics>`.

    Parameters
    ----------
    X : array-like, shape (n_samples, n_features)

    Y : array-like, shape (n_samples, n_features)

    Returns
    -------
    distances : ndarray (n_samples, )
    "
                :arguments 
                  ( ("X" variable nil (reparse-symbol function_parameters) [29124 29125])
                    ("Y" variable nil (reparse-symbol function_parameters) [29127 29128]))                  )
                nil [29093 29518])
            ("paired_manhattan_distances" function
               (:documentation "Compute the L1 distances between the vectors in X and Y.

    Read more in the :ref:`User Guide <metrics>`.

    Parameters
    ----------
    X : array-like, shape (n_samples, n_features)

    Y : array-like, shape (n_samples, n_features)

    Returns
    -------
    distances : ndarray (n_samples, )
    "
                :arguments 
                  ( ("X" variable nil (reparse-symbol function_parameters) [29551 29552])
                    ("Y" variable nil (reparse-symbol function_parameters) [29554 29555]))                  )
                nil [29520 30096])
            ("paired_cosine_distances" function
               (:documentation "
    Computes the paired cosine distances between X and Y

    Read more in the :ref:`User Guide <metrics>`.

    Parameters
    ----------
    X : array-like, shape (n_samples, n_features)

    Y : array-like, shape (n_samples, n_features)

    Returns
    -------
    distances : ndarray, shape (n_samples, )

    Notes
    -----
    The cosine distance is equivalent to the half the squared
    euclidean distance if each sample is normalized to unit norm
    "
                :arguments 
                  ( ("X" variable nil (reparse-symbol function_parameters) [30126 30127])
                    ("Y" variable nil (reparse-symbol function_parameters) [30129 30130]))                  )
                nil [30098 30713])
            ("PAIRED_DISTANCES" variable nil nil [30715 30985])
            ("paired_distances" function
               (:documentation "
    Computes the paired distances between X and Y.

    Computes the distances between (X[0], Y[0]), (X[1], Y[1]), etc...

    Read more in the :ref:`User Guide <metrics>`.

    Parameters
    ----------
    X : ndarray (n_samples, n_features)
        Array 1 for distance computation.

    Y : ndarray (n_samples, n_features)
        Array 2 for distance computation.

    metric : string or callable
        The metric to use when calculating distance between instances in a
        feature array. If metric is a string, it must be one of the options
        specified in PAIRED_DISTANCES, including \"euclidean\",
        \"manhattan\", or \"cosine\".
        Alternatively, if metric is a callable function, it is called on each
        pair of instances (rows) and the resulting value recorded. The callable
        should take two arrays from X as input and return a value indicating
        the distance between them.

    Returns
    -------
    distances : ndarray (n_samples, )

    Examples
    --------
    >>> from sklearn.metrics.pairwise import paired_distances
    >>> X = [[0, 1], [1, 1]]
    >>> Y = [[0, 1], [2, 1]]
    >>> paired_distances(X, Y)
    array([0., 1.])

    See also
    --------
    pairwise_distances : Computes the distance between every pair of samples
    "
                :arguments 
                  ( ("X" variable nil (reparse-symbol function_parameters) [31037 31038])
                    ("Y" variable nil (reparse-symbol function_parameters) [31040 31041])
                    ("metric" variable nil (reparse-symbol function_parameters) [31046 31052])
                    ("kwds" variable nil (reparse-symbol function_parameters) [31066 31072]))                  
                :decorators 
                  ( ("_deprecate_positional_args" function (:type "decorator") nil nil))                  )
                nil [30988 32820])
            ("linear_kernel" function
               (:documentation "
    Compute the linear kernel between X and Y.

    Read more in the :ref:`User Guide <linear_kernel>`.

    Parameters
    ----------
    X : array of shape (n_samples_1, n_features)

    Y : array of shape (n_samples_2, n_features)

    dense_output : boolean (optional), default True
        Whether to return dense output even when the input is sparse. If
        ``False``, the output is sparse if both input arrays are sparse.

        .. versionadded:: 0.20

    Returns
    -------
    Gram matrix : array of shape (n_samples_1, n_samples_2)
    "
                :arguments 
                  ( ("X" variable nil (reparse-symbol function_parameters) [32850 32851])
                    ("Y" variable nil (reparse-symbol function_parameters) [32853 32854])
                    ("dense_output" variable nil (reparse-symbol function_parameters) [32861 32873]))                  )
                nil [32832 33548])
            ("polynomial_kernel" function
               (:documentation "
    Compute the polynomial kernel between X and Y::

        K(X, Y) = (gamma <X, Y> + coef0)^degree

    Read more in the :ref:`User Guide <polynomial_kernel>`.

    Parameters
    ----------
    X : ndarray of shape (n_samples_1, n_features)

    Y : ndarray of shape (n_samples_2, n_features)

    degree : int, default 3

    gamma : float, default None
        if None, defaults to 1.0 / n_features

    coef0 : float, default 1

    Returns
    -------
    Gram matrix : array of shape (n_samples_1, n_samples_2)
    "
                :arguments 
                  ( ("X" variable nil (reparse-symbol function_parameters) [33572 33573])
                    ("Y" variable nil (reparse-symbol function_parameters) [33575 33576])
                    ("degree" variable nil (reparse-symbol function_parameters) [33583 33589])
                    ("gamma" variable nil (reparse-symbol function_parameters) [33593 33598])
                    ("coef0" variable nil (reparse-symbol function_parameters) [33605 33610]))                  )
                nil [33550 34356])
            ("sigmoid_kernel" function
               (:documentation "
    Compute the sigmoid kernel between X and Y::

        K(X, Y) = tanh(gamma <X, Y> + coef0)

    Read more in the :ref:`User Guide <sigmoid_kernel>`.

    Parameters
    ----------
    X : ndarray of shape (n_samples_1, n_features)

    Y : ndarray of shape (n_samples_2, n_features)

    gamma : float, default None
        If None, defaults to 1.0 / n_features

    coef0 : float, default 1

    Returns
    -------
    Gram matrix : array of shape (n_samples_1, n_samples_2)
    "
                :arguments 
                  ( ("X" variable nil (reparse-symbol function_parameters) [34377 34378])
                    ("Y" variable nil (reparse-symbol function_parameters) [34380 34381])
                    ("gamma" variable nil (reparse-symbol function_parameters) [34388 34393])
                    ("coef0" variable nil (reparse-symbol function_parameters) [34400 34405]))                  )
                nil [34358 35139])
            ("rbf_kernel" function
               (:documentation "
    Compute the rbf (gaussian) kernel between X and Y::

        K(x, y) = exp(-gamma ||x-y||^2)

    for each pair of rows x in X and y in Y.

    Read more in the :ref:`User Guide <rbf_kernel>`.

    Parameters
    ----------
    X : array of shape (n_samples_X, n_features)

    Y : array of shape (n_samples_Y, n_features)

    gamma : float, default None
        If None, defaults to 1.0 / n_features

    Returns
    -------
    kernel_matrix : array of shape (n_samples_X, n_samples_Y)
    "
                :arguments 
                  ( ("X" variable nil (reparse-symbol function_parameters) [35156 35157])
                    ("Y" variable nil (reparse-symbol function_parameters) [35159 35160])
                    ("gamma" variable nil (reparse-symbol function_parameters) [35167 35172]))                  )
                nil [35141 35905])
            ("laplacian_kernel" function
               (:documentation "Compute the laplacian kernel between X and Y.

    The laplacian kernel is defined as::

        K(x, y) = exp(-gamma ||x-y||_1)

    for each pair of rows x in X and y in Y.
    Read more in the :ref:`User Guide <laplacian_kernel>`.

    .. versionadded:: 0.17

    Parameters
    ----------
    X : array of shape (n_samples_X, n_features)

    Y : array of shape (n_samples_Y, n_features)

    gamma : float, default None
        If None, defaults to 1.0 / n_features

    Returns
    -------
    kernel_matrix : array of shape (n_samples_X, n_samples_Y)
    "
                :arguments 
                  ( ("X" variable nil (reparse-symbol function_parameters) [35928 35929])
                    ("Y" variable nil (reparse-symbol function_parameters) [35931 35932])
                    ("gamma" variable nil (reparse-symbol function_parameters) [35939 35944]))                  )
                nil [35907 36720])
            ("cosine_similarity" function
               (:documentation "Compute cosine similarity between samples in X and Y.

    Cosine similarity, or the cosine kernel, computes similarity as the
    normalized dot product of X and Y:

        K(X, Y) = <X, Y> / (||X||*||Y||)

    On L2-normalized data, this function is equivalent to linear_kernel.

    Read more in the :ref:`User Guide <cosine_similarity>`.

    Parameters
    ----------
    X : ndarray or sparse array, shape: (n_samples_X, n_features)
        Input data.

    Y : ndarray or sparse array, shape: (n_samples_Y, n_features)
        Input data. If ``None``, the output will be the pairwise
        similarities between all samples in ``X``.

    dense_output : boolean (optional), default True
        Whether to return dense output even when the input is sparse. If
        ``False``, the output is sparse if both input arrays are sparse.

        .. versionadded:: 0.17
           parameter ``dense_output`` for dense output.

    Returns
    -------
    kernel matrix : array
        An array with shape (n_samples_X, n_samples_Y).
    "
                :arguments 
                  ( ("X" variable nil (reparse-symbol function_parameters) [36744 36745])
                    ("Y" variable nil (reparse-symbol function_parameters) [36747 36748])
                    ("dense_output" variable nil (reparse-symbol function_parameters) [36755 36767]))                  )
                nil [36722 38171])
            ("additive_chi2_kernel" function
               (:documentation "Computes the additive chi-squared kernel between observations in X and Y

    The chi-squared kernel is computed between each pair of rows in X and Y.  X
    and Y have to be non-negative. This kernel is most commonly applied to
    histograms.

    The chi-squared kernel is given by::

        k(x, y) = -Sum [(x - y)^2 / (x + y)]

    It can be interpreted as a weighted difference per entry.

    Read more in the :ref:`User Guide <chi2_kernel>`.

    Notes
    -----
    As the negative of a distance, this kernel is only conditionally positive
    definite.


    Parameters
    ----------
    X : array-like of shape (n_samples_X, n_features)

    Y : array of shape (n_samples_Y, n_features)

    Returns
    -------
    kernel_matrix : array of shape (n_samples_X, n_samples_Y)

    References
    ----------
    * Zhang, J. and Marszalek, M. and Lazebnik, S. and Schmid, C.
      Local features and kernels for classification of texture and object
      categories: A comprehensive study
      International Journal of Computer Vision 2007
      https://research.microsoft.com/en-us/um/people/manik/projects/trade-off/papers/ZhangIJCV06.pdf


    See also
    --------
    chi2_kernel : The exponentiated version of the kernel, which is usually
        preferable.

    sklearn.kernel_approximation.AdditiveChi2Sampler : A Fourier approximation
        to this kernel.
    "
                :arguments 
                  ( ("X" variable nil (reparse-symbol function_parameters) [38198 38199])
                    ("Y" variable nil (reparse-symbol function_parameters) [38201 38202]))                  )
                nil [38173 40043])
            ("chi2_kernel" function
               (:documentation "Computes the exponential chi-squared kernel X and Y.

    The chi-squared kernel is computed between each pair of rows in X and Y.  X
    and Y have to be non-negative. This kernel is most commonly applied to
    histograms.

    The chi-squared kernel is given by::

        k(x, y) = exp(-gamma Sum [(x - y)^2 / (x + y)])

    It can be interpreted as a weighted difference per entry.

    Read more in the :ref:`User Guide <chi2_kernel>`.

    Parameters
    ----------
    X : array-like of shape (n_samples_X, n_features)

    Y : array of shape (n_samples_Y, n_features)

    gamma : float, default=1.
        Scaling parameter of the chi2 kernel.

    Returns
    -------
    kernel_matrix : array of shape (n_samples_X, n_samples_Y)

    References
    ----------
    * Zhang, J. and Marszalek, M. and Lazebnik, S. and Schmid, C.
      Local features and kernels for classification of texture and object
      categories: A comprehensive study
      International Journal of Computer Vision 2007
      https://research.microsoft.com/en-us/um/people/manik/projects/trade-off/papers/ZhangIJCV06.pdf

    See also
    --------
    additive_chi2_kernel : The additive version of this kernel

    sklearn.kernel_approximation.AdditiveChi2Sampler : A Fourier approximation
        to the additive version of this kernel.
    "
                :arguments 
                  ( ("X" variable nil (reparse-symbol function_parameters) [40061 40062])
                    ("Y" variable nil (reparse-symbol function_parameters) [40064 40065])
                    ("gamma" variable nil (reparse-symbol function_parameters) [40072 40077]))                  )
                nil [40045 41495])
            ("PAIRWISE_DISTANCE_FUNCTIONS" variable nil nil [41527 42047])
            ("distance_metrics" function (:documentation "Valid metrics for pairwise_distances.

    This function simply returns the valid pairwise distance metrics.
    It exists to allow for a description of the mapping for
    each of the valid strings.

    The valid distance metrics, and the function they map to, are:

    =============== ========================================
    metric          Function
    =============== ========================================
    'cityblock'     metrics.pairwise.manhattan_distances
    'cosine'        metrics.pairwise.cosine_distances
    'euclidean'     metrics.pairwise.euclidean_distances
    'haversine'     metrics.pairwise.haversine_distances
    'l1'            metrics.pairwise.manhattan_distances
    'l2'            metrics.pairwise.euclidean_distances
    'manhattan'     metrics.pairwise.manhattan_distances
    'nan_euclidean' metrics.pairwise.nan_euclidean_distances
    =============== ========================================

    Read more in the :ref:`User Guide <metrics>`.

    ") nil [42050 43118])
            ("_dist_wrapper" function
               (:documentation "Write in-place to a slice of a distance matrix"
                :arguments 
                  ( ("dist_func" variable nil (reparse-symbol function_parameters) [43138 43147])
                    ("dist_matrix" variable nil (reparse-symbol function_parameters) [43149 43160])
                    ("slice_" variable nil (reparse-symbol function_parameters) [43162 43168])
                    ("args" variable nil (reparse-symbol function_parameters) [43170 43175])
                    ("kwargs" variable nil (reparse-symbol function_parameters) [43177 43185]))                  )
                nil [43120 43301])
            ("_parallel_pairwise" function
               (:documentation "Break the pairwise matrix in n_jobs even slices
    and compute them in parallel"
                :arguments 
                  ( ("X" variable nil (reparse-symbol function_parameters) [43326 43327])
                    ("Y" variable nil (reparse-symbol function_parameters) [43329 43330])
                    ("func" variable nil (reparse-symbol function_parameters) [43332 43336])
                    ("n_jobs" variable nil (reparse-symbol function_parameters) [43338 43344])
                    ("kwds" variable nil (reparse-symbol function_parameters) [43346 43352]))                  )
                nil [43303 44143])
            ("_pairwise_callable" function
               (:documentation "Handle the callable case for pairwise_{distances,kernels}
    "
                :arguments 
                  ( ("X" variable nil (reparse-symbol function_parameters) [44168 44169])
                    ("Y" variable nil (reparse-symbol function_parameters) [44171 44172])
                    ("metric" variable nil (reparse-symbol function_parameters) [44174 44180])
                    ("force_all_finite" variable nil (reparse-symbol function_parameters) [44182 44198])
                    ("kwds" variable nil (reparse-symbol function_parameters) [44205 44211]))                  )
                nil [44145 45229])
            ("_VALID_METRICS" variable nil nil [45231 45699])
            ("_NAN_METRICS" variable nil nil [45701 45733])
            ("_check_chunk_size" function
               (:documentation "Checks chunk is a sequence of expected size or a tuple of same
    "
                :arguments 
                  ( ("reduced" variable nil (reparse-symbol function_parameters) [45758 45765])
                    ("chunk_size" variable nil (reparse-symbol function_parameters) [45767 45777]))                  )
                nil [45736 46637])
            ("_precompute_metric_params" function
               (:documentation "Precompute data-derived metric parameters if not provided
    "
                :arguments 
                  ( ("X" variable nil (reparse-symbol function_parameters) [46669 46670])
                    ("Y" variable nil (reparse-symbol function_parameters) [46672 46673])
                    ("metric" variable nil (reparse-symbol function_parameters) [46675 46681])
                    ("kwds" variable nil (reparse-symbol function_parameters) [46688 46694]))                  )
                nil [46639 47636])
            ("pairwise_distances_chunked" function
               (:documentation "Generate a distance matrix chunk by chunk with optional reduction

    In cases where not all of a pairwise distance matrix needs to be stored at
    once, this is used to calculate pairwise distances in
    ``working_memory``-sized chunks.  If ``reduce_func`` is given, it is run
    on each chunk and its return values are concatenated into lists, arrays
    or sparse matrices.

    Parameters
    ----------
    X : array [n_samples_a, n_samples_a] if metric == \"precomputed\", or,
        [n_samples_a, n_features] otherwise
        Array of pairwise distances between samples, or a feature array.

    Y : array [n_samples_b, n_features], optional
        An optional second feature array. Only allowed if
        metric != \"precomputed\".

    reduce_func : callable, optional
        The function which is applied on each chunk of the distance matrix,
        reducing it to needed values.  ``reduce_func(D_chunk, start)``
        is called repeatedly, where ``D_chunk`` is a contiguous vertical
        slice of the pairwise distance matrix, starting at row ``start``.
        It should return one of: None; an array, a list, or a sparse matrix
        of length ``D_chunk.shape[0]``; or a tuple of such objects. Returning
        None is useful for in-place operations, rather than reductions.

        If None, pairwise_distances_chunked returns a generator of vertical
        chunks of the distance matrix.

    metric : string, or callable
        The metric to use when calculating distance between instances in a
        feature array. If metric is a string, it must be one of the options
        allowed by scipy.spatial.distance.pdist for its metric parameter, or
        a metric listed in pairwise.PAIRWISE_DISTANCE_FUNCTIONS.
        If metric is \"precomputed\", X is assumed to be a distance matrix.
        Alternatively, if metric is a callable function, it is called on each
        pair of instances (rows) and the resulting value recorded. The callable
        should take two arrays from X as input and return a value indicating
        the distance between them.

    n_jobs : int or None, optional (default=None)
        The number of jobs to use for the computation. This works by breaking
        down the pairwise matrix into n_jobs even slices and computing them in
        parallel.

        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.
        ``-1`` means using all processors. See :term:`Glossary <n_jobs>`
        for more details.

    working_memory : int, optional
        The sought maximum memory for temporary distance matrix chunks.
        When None (default), the value of
        ``sklearn.get_config()['working_memory']`` is used.

    `**kwds` : optional keyword parameters
        Any further parameters are passed directly to the distance function.
        If using a scipy.spatial.distance metric, the parameters are still
        metric dependent. See the scipy docs for usage examples.

    Yields
    ------
    D_chunk : array or sparse matrix
        A contiguous slice of distance matrix, optionally processed by
        ``reduce_func``.

    Examples
    --------
    Without reduce_func:

    >>> import numpy as np
    >>> from sklearn.metrics import pairwise_distances_chunked
    >>> X = np.random.RandomState(0).rand(5, 3)
    >>> D_chunk = next(pairwise_distances_chunked(X))
    >>> D_chunk
    array([[0.  ..., 0.29..., 0.41..., 0.19..., 0.57...],
           [0.29..., 0.  ..., 0.57..., 0.41..., 0.76...],
           [0.41..., 0.57..., 0.  ..., 0.44..., 0.90...],
           [0.19..., 0.41..., 0.44..., 0.  ..., 0.51...],
           [0.57..., 0.76..., 0.90..., 0.51..., 0.  ...]])

    Retrieve all neighbors and average distance within radius r:

    >>> r = .2
    >>> def reduce_func(D_chunk, start):
    ...     neigh = [np.flatnonzero(d < r) for d in D_chunk]
    ...     avg_dist = (D_chunk * (D_chunk < r)).mean(axis=1)
    ...     return neigh, avg_dist
    >>> gen = pairwise_distances_chunked(X, reduce_func=reduce_func)
    >>> neigh, avg_dist = next(gen)
    >>> neigh
    [array([0, 3]), array([1]), array([2]), array([0, 3]), array([4])]
    >>> avg_dist
    array([0.039..., 0.        , 0.        , 0.039..., 0.        ])

    Where r is defined per sample, we need to make use of ``start``:

    >>> r = [.2, .4, .4, .3, .1]
    >>> def reduce_func(D_chunk, start):
    ...     neigh = [np.flatnonzero(d < r[i])
    ...              for i, d in enumerate(D_chunk, start)]
    ...     return neigh
    >>> neigh = next(pairwise_distances_chunked(X, reduce_func=reduce_func))
    >>> neigh
    [array([0, 3]), array([0, 1]), array([2]), array([0, 3]), array([4])]

    Force row-by-row generation by reducing ``working_memory``:

    >>> gen = pairwise_distances_chunked(X, reduce_func=reduce_func,
    ...                                  working_memory=0)
    >>> next(gen)
    [array([0, 3])]
    >>> next(gen)
    [array([0, 1])]
    "
                :arguments 
                  ( ("X" variable nil (reparse-symbol function_parameters) [47697 47698])
                    ("Y" variable nil (reparse-symbol function_parameters) [47700 47701])
                    ("reduce_func" variable nil (reparse-symbol function_parameters) [47711 47722])
                    ("metric" variable nil (reparse-symbol function_parameters) [47760 47766])
                    ("n_jobs" variable nil (reparse-symbol function_parameters) [47780 47786])
                    ("working_memory" variable nil (reparse-symbol function_parameters) [47824 47838])
                    ("kwds" variable nil (reparse-symbol function_parameters) [47845 47851]))                  
                :decorators 
                  ( ("_deprecate_positional_args" function (:type "decorator") nil nil))                  )
                nil [47638 54611])
            ("pairwise_distances" function
               (:documentation " Compute the distance matrix from a vector array X and optional Y.

    This method takes either a vector array or a distance matrix, and returns
    a distance matrix. If the input is a vector array, the distances are
    computed. If the input is a distances matrix, it is returned instead.

    This method provides a safe way to take a distance matrix as input, while
    preserving compatibility with many other algorithms that take a vector
    array.

    If Y is given (default is None), then the returned matrix is the pairwise
    distance between the arrays from both X and Y.

    Valid values for metric are:

    - From scikit-learn: ['cityblock', 'cosine', 'euclidean', 'l1', 'l2',
      'manhattan']. These metrics support sparse matrix
      inputs.
      ['nan_euclidean'] but it does not yet support sparse matrices.

    - From scipy.spatial.distance: ['braycurtis', 'canberra', 'chebyshev',
      'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski', 'mahalanobis',
      'minkowski', 'rogerstanimoto', 'russellrao', 'seuclidean',
      'sokalmichener', 'sokalsneath', 'sqeuclidean', 'yule']
      See the documentation for scipy.spatial.distance for details on these
      metrics. These metrics do not support sparse matrix inputs.

    Note that in the case of 'cityblock', 'cosine' and 'euclidean' (which are
    valid scipy.spatial.distance metrics), the scikit-learn implementation
    will be used, which is faster and has support for sparse matrices (except
    for 'cityblock'). For a verbose description of the metrics from
    scikit-learn, see the __doc__ of the sklearn.pairwise.distance_metrics
    function.

    Read more in the :ref:`User Guide <metrics>`.

    Parameters
    ----------
    X : array [n_samples_a, n_samples_a] if metric == \"precomputed\", or, \\
             [n_samples_a, n_features] otherwise
        Array of pairwise distances between samples, or a feature array.

    Y : array [n_samples_b, n_features], optional
        An optional second feature array. Only allowed if
        metric != \"precomputed\".

    metric : string, or callable
        The metric to use when calculating distance between instances in a
        feature array. If metric is a string, it must be one of the options
        allowed by scipy.spatial.distance.pdist for its metric parameter, or
        a metric listed in pairwise.PAIRWISE_DISTANCE_FUNCTIONS.
        If metric is \"precomputed\", X is assumed to be a distance matrix.
        Alternatively, if metric is a callable function, it is called on each
        pair of instances (rows) and the resulting value recorded. The callable
        should take two arrays from X as input and return a value indicating
        the distance between them.

    n_jobs : int or None, optional (default=None)
        The number of jobs to use for the computation. This works by breaking
        down the pairwise matrix into n_jobs even slices and computing them in
        parallel.

        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.
        ``-1`` means using all processors. See :term:`Glossary <n_jobs>`
        for more details.

    force_all_finite : boolean or 'allow-nan', (default=True)
        Whether to raise an error on np.inf, np.nan, pd.NA in array. The
        possibilities are:

        - True: Force all values of array to be finite.
        - False: accepts np.inf, np.nan, pd.NA in array.
        - 'allow-nan': accepts only np.nan and pd.NA values in array. Values
          cannot be infinite.

        .. versionadded:: 0.22
           ``force_all_finite`` accepts the string ``'allow-nan'``.

        .. versionchanged:: 0.23
           Accepts `pd.NA` and converts it into `np.nan`

    **kwds : optional keyword parameters
        Any further parameters are passed directly to the distance function.
        If using a scipy.spatial.distance metric, the parameters are still
        metric dependent. See the scipy docs for usage examples.

    Returns
    -------
    D : array [n_samples_a, n_samples_a] or [n_samples_a, n_samples_b]
        A distance matrix D such that D_{i, j} is the distance between the
        ith and jth vectors of the given matrix X, if Y is None.
        If Y is not None, then D_{i, j} is the distance between the ith array
        from X and the jth array from Y.

    See also
    --------
    pairwise_distances_chunked : performs the same calculation as this
        function, but returns a generator of chunks of the distance matrix, in
        order to limit memory usage.
    paired_distances : Computes the distances between corresponding
                       elements of two arrays
    "
                :arguments 
                  ( ("X" variable nil (reparse-symbol function_parameters) [54664 54665])
                    ("Y" variable nil (reparse-symbol function_parameters) [54667 54668])
                    ("metric" variable nil (reparse-symbol function_parameters) [54675 54681])
                    ("n_jobs" variable nil (reparse-symbol function_parameters) [54698 54704])
                    ("force_all_finite" variable nil (reparse-symbol function_parameters) [54734 54750])
                    ("kwds" variable nil (reparse-symbol function_parameters) [54757 54763]))                  
                :decorators 
                  ( ("_deprecate_positional_args" function (:type "decorator") nil nil))                  )
                nil [54613 61381])
            ("PAIRWISE_BOOLEAN_FUNCTIONS" variable nil nil [61459 61643])
            ("PAIRWISE_KERNEL_FUNCTIONS" variable nil nil [61675 62110])
            ("kernel_metrics" function (:documentation " Valid metrics for pairwise_kernels

    This function simply returns the valid pairwise distance metrics.
    It exists, however, to allow for a verbose description of the mapping for
    each of the valid strings.

    The valid distance metrics, and the function they map to, are:
      ===============   ========================================
      metric            Function
      ===============   ========================================
      'additive_chi2'   sklearn.pairwise.additive_chi2_kernel
      'chi2'            sklearn.pairwise.chi2_kernel
      'linear'          sklearn.pairwise.linear_kernel
      'poly'            sklearn.pairwise.polynomial_kernel
      'polynomial'      sklearn.pairwise.polynomial_kernel
      'rbf'             sklearn.pairwise.rbf_kernel
      'laplacian'       sklearn.pairwise.laplacian_kernel
      'sigmoid'         sklearn.pairwise.sigmoid_kernel
      'cosine'          sklearn.pairwise.cosine_similarity
      ===============   ========================================

    Read more in the :ref:`User Guide <metrics>`.
    ") nil [62113 63263])
            ("KERNEL_PARAMS" variable nil nil [63265 63609])
            ("pairwise_kernels" function
               (:documentation "Compute the kernel between arrays X and optional array Y.

    This method takes either a vector array or a kernel matrix, and returns
    a kernel matrix. If the input is a vector array, the kernels are
    computed. If the input is a kernel matrix, it is returned instead.

    This method provides a safe way to take a kernel matrix as input, while
    preserving compatibility with many other algorithms that take a vector
    array.

    If Y is given (default is None), then the returned matrix is the pairwise
    kernel between the arrays from both X and Y.

    Valid values for metric are:
        ['additive_chi2', 'chi2', 'linear', 'poly', 'polynomial', 'rbf',
        'laplacian', 'sigmoid', 'cosine']

    Read more in the :ref:`User Guide <metrics>`.

    Parameters
    ----------
    X : array [n_samples_a, n_samples_a] if metric == \"precomputed\", or, \\
             [n_samples_a, n_features] otherwise
        Array of pairwise kernels between samples, or a feature array.

    Y : array [n_samples_b, n_features]
        A second feature array only if X has shape [n_samples_a, n_features].

    metric : string, or callable
        The metric to use when calculating kernel between instances in a
        feature array. If metric is a string, it must be one of the metrics
        in pairwise.PAIRWISE_KERNEL_FUNCTIONS.
        If metric is \"precomputed\", X is assumed to be a kernel matrix.
        Alternatively, if metric is a callable function, it is called on each
        pair of instances (rows) and the resulting value recorded. The callable
        should take two rows from X as input and return the corresponding
        kernel value as a single number. This means that callables from
        :mod:`sklearn.metrics.pairwise` are not allowed, as they operate on
        matrices, not single samples. Use the string identifying the kernel
        instead.

    filter_params : boolean
        Whether to filter invalid parameters or not.

    n_jobs : int or None, optional (default=None)
        The number of jobs to use for the computation. This works by breaking
        down the pairwise matrix into n_jobs even slices and computing them in
        parallel.

        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.
        ``-1`` means using all processors. See :term:`Glossary <n_jobs>`
        for more details.

    **kwds : optional keyword parameters
        Any further parameters are passed directly to the kernel function.

    Returns
    -------
    K : array [n_samples_a, n_samples_a] or [n_samples_a, n_samples_b]
        A kernel matrix K such that K_{i, j} is the kernel between the
        ith and jth vectors of the given matrix X, if Y is None.
        If Y is not None, then K_{i, j} is the kernel between the ith array
        from X and the jth array from Y.

    Notes
    -----
    If metric is 'precomputed', Y is ignored and X is returned.

    "
                :arguments 
                  ( ("X" variable nil (reparse-symbol function_parameters) [63661 63662])
                    ("Y" variable nil (reparse-symbol function_parameters) [63664 63665])
                    ("metric" variable nil (reparse-symbol function_parameters) [63672 63678])
                    ("filter_params" variable nil (reparse-symbol function_parameters) [63692 63705])
                    ("n_jobs" variable nil (reparse-symbol function_parameters) [63734 63740])
                    ("kwds" variable nil (reparse-symbol function_parameters) [63747 63753]))                  
                :decorators 
                  ( ("_deprecate_positional_args" function (:type "decorator") nil nil))                  )
                nil [63612 67429]))          
      :file "pairwise.py"
      :pointmax 67429
      :fsize 67430
      :lastmodtime '(24344 10759 167572 975000)
      :unmatched-syntax '((PERIOD 66762 . 66763) (FROM 66756 . 66760) (PERIOD 66761 . 66762) (MULT 63689 . 63690) (COMMA 63690 . 63691) (NAME 60495 . 60500) (IF 60508 . 60510) (ELSE 60548 . 60552) (MULT 54695 . 54696) (COMMA 54696 . 54697) (MULT 47708 . 47709) (COMMA 47709 . 47710) (MULT 31043 . 31044) (COMMA 31044 . 31045) (MULT 25502 . 25503) (COMMA 25503 . 25504) (MULT 21096 . 21097) (COMMA 21097 . 21098) (MULT 18131 . 18132) (COMMA 18132 . 18133) (NAME 15883 . 15892) (IF 15920 . 15922) (ELSE 15935 . 15939) (NAME 15816 . 15825) (IF 15853 . 15855) (ELSE 15868 . 15872) (NAME 14895 . 14904) (IF 14917 . 14919) (ELSE 14927 . 14931) (NAME 14248 . 14257) (IF 14270 . 14272) (ELSE 14280 . 14284) (NAME 13927 . 13943) (IF 13958 . 13960) (ELSE 13991 . 13995) (MULT 11641 . 11642) (COMMA 11642 . 11643) (RETURN 11505 . 11511) (IF 11522 . 11524) (ELSE 11533 . 11537) (MULT 7322 . 7323) (COMMA 7323 . 7324) (MULT 1829 . 1830) (COMMA 1830 . 1831) (PERIOD 1144 . 1145) (FROM 1138 . 1142) (PERIOD 1143 . 1144) (FROM 1073 . 1077) (PERIOD 1078 . 1079) (PERIOD 1020 . 1021) (FROM 1014 . 1018) (PERIOD 1019 . 1020) (PERIOD 984 . 985) (FROM 978 . 982) (PERIOD 983 . 984) (PERIOD 946 . 947) (FROM 940 . 944) (PERIOD 945 . 946) (PERIOD 891 . 892) (FROM 885 . 889) (PERIOD 890 . 891) (PERIOD 857 . 858) (FROM 851 . 855) (PERIOD 856 . 857) (PERIOD 807 . 808) (FROM 801 . 805) (PERIOD 806 . 807) (PERIOD 771 . 772) (FROM 765 . 769) (PERIOD 770 . 771) (PERIOD 739 . 740) (FROM 733 . 737) (PERIOD 738 . 739) (PERIOD 689 . 690) (FROM 683 . 687) (PERIOD 688 . 689) (PERIOD 645 . 646) (FROM 639 . 643) (PERIOD 644 . 645))))
  :file "!usr!local!lib!python3.8!dist-packages!sklearn!metrics!semantic.cache"
  :semantic-tag-version "2.0"
  :semanticdb-version "2.2")
